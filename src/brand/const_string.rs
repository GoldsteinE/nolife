//! Branding based on lifting static strings to the type level
//!
//! Complex and requires `adt_const_params`, but produces nice error messages

/// An unique type generated by the [`brand!`] macro.
/// Guaranteed to be zero-sized.
///
/// This wouldn't compile:
/// ```compile_fail
/// # use nolife::brand::const_string::*;
/// fn assert_same_type<T>(_: T, _: T) {}
/// assert_same_type(brand!(), brand!())
/// ```
#[repr(transparent)]
pub struct Brand<const S: &'static str>(());

impl<const S: &'static str> Brand<S> {
    /// An implementation detail used by the [`brand!`] macro. Don't use it unless you new exactly
    /// what you're doing.
    ///
    /// # Safety
    /// This can be used to create a duplicate brand, which has same safety implications as
    /// [`IsBrand::duplicate`](super::IsBrand::duplicate)
    #[must_use]
    pub unsafe fn new() -> Self {
        Self(())
    }
}

impl<const S: &'static str> super::sealed::Seal for Brand<S> {}
impl<const S: &'static str> super::IsBrand for Brand<S> {
    unsafe fn duplicate(self) -> (Self, Self) {
        (self, Self(()))
    }
}

/// Generate a new unique brand. This is safe since macro will yield a new brand every time
#[macro_export]
// Unfortunately, macros are not scoped properly
#[allow(clippy::module_name_repetitions)]
macro_rules! _const_string_brand {
    () => {{
        const BRAND: &::core::primitive::str = ::core::concat!(
            "brand at ",
            ::core::file!(),
            ":",
            ::core::line!(),
            ":",
            ::core::column!()
        );
        unsafe { $crate::brand::const_string::Brand::<BRAND>::new() }
    }};
}

pub use crate::_const_string_brand as brand;
